// lib/features/goods_receiving/data/goods_receiving_composite_repository.dart
import 'package:flutter/foundation.dart';
import '../../../core/network/network_info.dart';
import '../domain/entities/goods_receipt_entities.dart';
import '../domain/entities/product_info.dart';
import '../domain/repositories/goods_receiving_repository.dart';
import './local/goods_receiving_local_service.dart';
import './remote/goods_receiving_api_service.dart';

class GoodsReceivingRepositoryImpl implements GoodsReceivingRepository {
  final GoodsReceivingLocalDataSource localDataSource;
  final GoodsReceivingRemoteDataSource remoteDataSource;
  final NetworkInfo networkInfo;

  GoodsReceivingRepositoryImpl({
    required this.localDataSource,
    required this.remoteDataSource,
    required this.networkInfo,
  });

  @override
  Future<List<String>> getInvoices() async {
    if (await networkInfo.isConnected) {
      try {
        return await remoteDataSource.fetchInvoices();
      } catch (e) {
        debugPrint("API getInvoices error: $e. Falling back to local.");
        return await localDataSource.getInvoiceNumbers();
      }
    }
    return await localDataSource.getInvoiceNumbers();
  }

  @override
  Future<List<String>> getPalletsForDropdown() async {
    if (await networkInfo.isConnected) {
      try {
        return await remoteDataSource.fetchPalletsForDropdown();
      } catch (e) {
        debugPrint("API getPalletsForDropdown error: $e. Falling back to local.");
        return await localDataSource.getPalletIds();
      }
    }
    return await localDataSource.getPalletIds();
  }

  @override
  Future<List<String>> getBoxesForDropdown() async {
    if (await networkInfo.isConnected) {
      try {
        return await remoteDataSource.fetchBoxesForDropdown();
      } catch (e) {
        debugPrint("API getBoxesForDropdown error: $e. Falling back to local.");
        return await localDataSource.getBoxIds();
      }
    }
    return await localDataSource.getBoxIds();
  }

  @override
  Future<List<ProductInfo>> getProductsForDropdown() async {
    if (await networkInfo.isConnected) {
      try {
        final products = await remoteDataSource.fetchProductsForDropdown();
        return products;
      } catch (e) {
        debugPrint("API getProductsForDropdown error: $e. Falling back to local.");
        return await localDataSource.getProductsForDropdown();
      }
    }
    return await localDataSource.getProductsForDropdown();
  }

  @override
  Future<int> saveGoodsReceipt(GoodsReceipt header, List<GoodsReceiptItem> items) async {
    bool isOnline = await networkInfo.isConnected;
    GoodsReceipt headerToSave;

    // Preserve existing id if present, otherwise it's a new record.
    // externalId is generated by the constructor if not provided, so it will always exist on `header`.

    if (isOnline) {
      try {
        bool apiSuccess = await remoteDataSource.sendGoodsReceipt(header, items);
        if (apiSuccess) {
          headerToSave = GoodsReceipt(
            id: header.id, // Preserve original id if it exists
            externalId: header.externalId, // Preserve original or newly generated externalId
            invoiceNumber: header.invoiceNumber,
            receiptDate: header.receiptDate,
            mode: header.mode,
            synced: 1, // Mark as synced
          );
          debugPrint("Goods Receipt data prepared for API, marked as synced.");
        } else {
          headerToSave = GoodsReceipt(
            id: header.id,
            externalId: header.externalId,
            invoiceNumber: header.invoiceNumber,
            receiptDate: header.receiptDate,
            mode: header.mode,
            synced: 0, // API call failed
          );
          debugPrint("Goods Receipt API call failed, marked as not synced.");
        }
      } catch (e) {
        debugPrint("API error during sendGoodsReceipt: $e. Marked as not synced.");
        headerToSave = GoodsReceipt(
          id: header.id,
          externalId: header.externalId,
          invoiceNumber: header.invoiceNumber,
          receiptDate: header.receiptDate,
          mode: header.mode,
          synced: 0, // API error
        );
      }
    } else {
      // Offline, mark as not synced
      headerToSave = GoodsReceipt(
        id: header.id,
        externalId: header.externalId,
        invoiceNumber: header.invoiceNumber,
        receiptDate: header.receiptDate,
        mode: header.mode,
        synced: 0,
      );
      debugPrint("Offline: Goods Receipt marked as not synced.");
    }

    final localId = await localDataSource.saveGoodsReceipt(headerToSave, items);
    debugPrint("Goods Receipt (local id: $localId) saved locally with synced status: ${headerToSave.synced}. ExternalId: ${headerToSave.externalId}");

    final Set<String> uniquePalletOrBoxIds = items.map((item) => item.palletOrBoxId).toSet();
    for (String pId in uniquePalletOrBoxIds) {
      await localDataSource.setContainerInitialLocation(pId, "MAL KABUL", headerToSave.receiptDate);
    }

    return localId;
  }

  @override
  Future<List<GoodsReceipt>> getUnsyncedGoodsReceipts() async {
    return await localDataSource.getUnsyncedGoodsReceipts();
  }

  @override
  Future<List<GoodsReceiptItem>> getItemsForGoodsReceipt(int receiptId) async {
    return await localDataSource.getItemsForGoodsReceipt(receiptId);
  }

  @override
  Future<void> markGoodsReceiptAsSynced(int receiptId) async {
    // First, get the header to obtain its externalId for robust API interaction if needed later
    // This step might be optional if only local marking is required.
    // GoodsReceipt? header = await localDataSource.getGoodsReceiptById(receiptId); // Assuming such a method exists

    await localDataSource.markGoodsReceiptAsSynced(receiptId);
    // debugPrint("Marked goods receipt ID: $receiptId (External ID: ${header?.externalId}) as synced.");
  }

  Future<void> synchronizePendingGoodsReceipts() async {
    if (await networkInfo.isConnected) {
      debugPrint("Starting synchronization of pending goods receipts...");
      final unsyncedReceipts = await getUnsyncedGoodsReceipts();
      if (unsyncedReceipts.isEmpty) {
        debugPrint("No unsynced goods receipts to synchronize.");
        return;
      }
      debugPrint("Found ${unsyncedReceipts.length} unsynced goods receipts.");

      for (var header in unsyncedReceipts) {
        // Ensure header.id is not null before proceeding.
        // The localDataSource should always return headers with an ID from the DB.
        if (header.id == null) {
          debugPrint("Skipping sync for header with null local ID (externalId: ${header.externalId}). This should not happen for locally saved records.");
          continue;
        }

        final items = await getItemsForGoodsReceipt(header.id!);
        // The header object from getUnsyncedGoodsReceipts already has all necessary info (including externalId).
        try {
          bool success = await remoteDataSource.sendGoodsReceipt(header, items);
          if (success) {
            await markGoodsReceiptAsSynced(header.id!); // Use local DB ID here
            debugPrint("Successfully synced goods receipt id: ${header.id} (externalId: ${header.externalId})");
          } else {
            debugPrint("Failed to sync goods receipt id: ${header.id} (externalId: ${header.externalId}) (API returned false).");
          }
        } catch (e) {
          debugPrint("Error syncing goods receipt id: ${header.id} (externalId: ${header.externalId}). Error: $e");
        }
      }
      debugPrint("Goods receipts synchronization process finished.");
    } else {
      debugPrint("Cannot synchronize goods receipts, no network connection.");
    }
  }
}
